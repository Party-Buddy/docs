# Общая архитектура бэкэнда

## Компоненты
На бэкэнде размещаются следующие кусочки:

1. **HTTP API.**
   Обработка запросов по HTTP API.
   Большая часть — простой CRUD для сущностей, которые персистятся в базу данных.
   Отдельно стоит выделить создание сессии, потому что оно служит мостом между этим пунктом и следующим.
   Здесь же сёрвится статика, как ни странно.
2. **Тягун БД.**
   Пишет SQL в БД и синтезирует структурки-ответы для всего остального бэка.
   - Название очень странное, зато короткое и однозначное в документе.
3. **Менеджер сессий.**
   Управление игровыми сессиями.
   Компонент обладает авторитативной информацией о всех живых сессиях.
   Он же занимается обновлением этой информации.
   В отличие от HTTP API, у которого всё состояние в БД, здесь стейт волатильный и не сохраняется между рестартами сервера.
4. **Вебсокеты.**
   Обработка сообщений по вебсокетному протоколу сессии.
   Сообщения отображаются в вызовы функций у менеджера игровых сессий из предыдущего пункта.
5. **GC.**
   Периодическая сборка мусора — неиспользуемых картинок.

### HTTP API
Никаких удивительных открытий здесь не найдётся.
Проверяем доступ (по владельцу и списку админов), работаем с ресурсом и загружаем обратно в БД через [тягун].

Здесь же обрабатываются GET/PUT-запросы для картиночек.
Мы хотим давать доступ на GET только тем, кто картинку должен видеть.
Здесь надо учесть все сценарии, которые право это дают:

- **картинка внутри сессии:** доступ имеют участники сессии
- **картинка публичной игры или задания:** доступ имеют все

Алгоритм проверки такой:
- если картинка публичная, то **allow**
- если список сессий, использующих картинку, пересекается со списком сессий, в которых клиент участвует, то **allow**
- иначе **deny**

Итого: нужно в БД на каждое обращение проходиться по 3 таблицам, затем запрашивать у [менеджера][менеджер] список сессий для клиента.

### Тягун БД
Пласт кода, который будет напосредственно отсылать SQL в БД и вытягивать оттуда структурки-ответы.
СУБД — Postgres, и его фишки юзать не стесняемся: всякие `RETURNING` и прочие прелести жизни.

### Менеджер сессий
Хранит и бережёт информацию о сессиях.
Тут нужно не забыть о многопотоке и засинхронизировать весь доступ к состоянию.
На меняющиеся кишки данных о сессиях ссылки никому не отдавать.
Все данные только копировать.

> Закинуть строку на кучу, записать ссылку на неё в состояние и вернуть из функции другому компоненту — ок.
> Потому что строки иммутабельны.

Этот же компонент двигает состояние игры: начинает игру, начинает задание, собирает баллы по результатам заданий и инициирует отправку сообщений на клиенты.

Кстати, у него всё-таки есть кусочек состояния, которое кладётся в БД.
Это ссылки на используемые картинки.
При старте сервера табличка с этими ссылками просто транкейтится.

Скорее всего, просто запустим по одной горутине на сессию.

#### Айдишники сессий
Будет 2 идентификатора.

- `invite-code`: используется для присоединения пользователей.
  Устаревает после начала игры.
- `session-id`: UUID сессии.

`session-id` будет отдаваться после захода в сессию по инвайт-коду.
Потом по этому айдишнику можно будет спокойно переподключаться.

### Вебсокеты
Здесь обслуживаются вебсокет-соединения.
Только этот кусок бэкэнда сам читает и отсылает сообщения между сервером и клиентом.

Всё клиентское состояние, которое мы не хотим потерять, если клиент перезашёл в игру после микролага, должно лежать в [менеджере][менеджер].
Этот же компонент будет просто декодировать сообщения и перенаправлять вызов на [менеджер].

Ещё [вебсокеты] получают указания от [менеджера][менеджер] на отправку сообщений клиенту.

Скорее всего, просто запустим по горутине на соединение.
Обрабатываться сообщения будут по очереди без параллелизма внутри соединения.

### GC
Отдельная таска периодически ходит в БД (через [тягун], конечно) и ищет пикчи без ссылок.
Затем зачищает фс от такого мусора.

## Взаимодействие между компонентами
Пока предполагаю, что взаимодействовать должны 2 сервиса: [вебсокеты] и [менеджер], для этого по-любому понадобятся каналы.

Остальное, думаю, можно разрешить через передачу в качестве параметров конструктора, метода, функции.

[HTTP API]: #HTTP-API
[Тягун]: #Тягун-БД
[Менеджер]: #Менеджер-сессий
[Вебсокеты]: #Вебсокеты
[GC]: #GC
